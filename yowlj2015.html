<!DOCTYPE html>
<html>
  <head>
    <title>Real World Property Based Testing</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: Futura, 'Yanone Kaffeesatz';
      }
      li {
        font-size: 30px;
        padding-top: 20px;
      }
      .remark-code {
        font-size: 30px;
      }
      h1, h2, h3 {
        font-weight: normal;
      }
      .inverse {
        background: #4795c6;
        color: white;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
      }
      .starwars {
        background: black;
        color: #07ffff;
      }
      .starwars li {
         text-align: justify;
         color: #ff6;
      }
      .relative h1 {
        position: relative !important;
      }
      .question {
        background: #76b242;
        color: white;
      }
      .rule {
        background: #ee2a24;
        color: white;
      }
      .image {
        padding: 0px;
        color: white;
        background-color: black;

        position: relative;
      }
      .image img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        /*height: 100%;*/
        float: left;
      }
      .image h1, .image h2 {
        position: absolute;
        bottom: 0;
        text-align: center;
        left: 20px;
      }
      .image-white {
        color: black;
        background-color: white;
      }
      .image-last h1 {
        right: 0;
        bottom: 100px;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }
      .remark-slide-content {
        padding: 10px 10px 10px 30px;
      }
      .hljs-default .hljs {
        background-color: transparent;
      }
      .ambiata-full {
        background-image: url(http://ambiata.com/images/ambiata_avatar.png);
      }
      .evolution {
        background-color: #DEDEDE;
      }
      .evolution h1 {
        color: black !important;
      }
      .top h1 {
        top: 0px;
      }
      /*
      .ambiata-full h2 {
        position: absolute;
        bottom: 0;
        right: 0;
      }
      */
      .ambiata {
        background-image: url(http://ambiata.com/images/ambiata_avatar.png);
        background-position: top right;
        background-size: 100px;
        /*-webkit-filter: grayscale(40%);*/
      }
      .code-small .remark-code {
        font-size: 20px;
      }
    </style>
  </head>
  <body>

    <textarea id="source">
name: image
layout: true
class: center, middle, image

---
name: image-white
layout: true
class: center, middle, image, image-white

---
name: image-last
layout: true
class: center, middle, image, image-last

---
name: ambiata
layout: true
class: ambiata

---
name: ambiata-full
layout: true
class: center, middle, ambiata-full

---
name: code-small
layout: true
class: code-small

---
name: question
layout: true
class: center, middle, question

---
name: rule
layout: true
class: center, middle, rule

---
name: inverse
layout: true
class: center, middle, inverse

---
name: starwars
layout: true
class: center, middle, starwars

---

class: center, middle
template: image

<img src="images/love-the-bomb.jpg" height="100%" />

# How I learned to stop unit testing and love property-based testing

---

layout: false
template: image

<img src="images/chopsticks.jpg" />

# Charles O'Farrell












---
template: starwars

## One year ago

- Had heard good things about property-based testing
- Had written one or two properties
- But found it hard work :(

---

template: image-white

<img src="images/jedi-master.jpg" height="100%" />

# Today











---

layout: false
## Let the healing begin

```scala
trait List[A] {
  def headOption: Option[A]
}
```

---

## Examples

```scala
Nil.headOption = None

List(1).headOption = Some(1)

List(1, 2).headOption = Some(1)

List(1, 2, 3).headOption = Some(1)

...
```

---

## Umm, now what?

```scala
forAll { l: List[Int] =>
  l.headOption =?
    ???
}
```

---

## Rookie mistake

```scala
forAll { l: List[Int] =>
  l.headOption =?
    (if (l.isEmpty) None else Some(l.head))
}

```

---

## Echo

```scala
forAll { l: List[Int] =>
  l.headOption =?
    (if (l.isEmpty) None else Some(l.head))
}

trait List[A] {
  def headOption: Option[A] =
    if (isEmpty) None else Some(head)
}
```

---
template: question

## This calls for...













---
template: image-white

<img src="images/patterns.jpg" style="width: 50%; left: 25%" />

# Patterns

---
layout: false

## Patterns

- Symmetry
- Multiple paths
- Induction
- Invariants
  - Idempotence
  - Consistency

---
template: inverse

## Symmetry

---
template: image-white

<img src="images/property-inverse.png" style="margin-top: 150px" />

---

## Show me the code

```scala
forAll { s: String =>
  val b = s.getBytes
  new String(b) =? s
}
```

---

## Watch out for encoding!

```scala
forAll { (s: String, c: Charset) =>
  val b = s.getBytes(c)
  new String(b, c) =? s
}
```

---
template: rule

```
> ARG_0: "돪"
> ARG_1: windows-1252
Expected "돪" but got "?"
```

---

## Files

```scala
forAll { (s: String, c: Codec) =>
  val f = File.createTempFile
  write(f, s, c)
  read(f, c) =? s
}
```

---

## JSON

```scala
def toJson(user: User): Json
def fromJson(Json): Either[Exception, User]
```

```scala
forAll { user: User =>
  fromJson(toJson(user)) =? Right(user)
}
```

---

## Data Structures

```scala
forAll { l: List[Int] =>
  l.toStream.toList =? l
}

forAll { l: List[Int] =>
  l.toVector.toList =? l
}
```

---

## Database

```scala
forall { u1: User =>
  val id = UserDB.insert(u1)
  val u2 = UserDB.get(id)

  u2 =? Some(u1)
}
```

---
template: rule

```
Expected Some(User(\NULL)) but got Some(User())
```

---
template: image

<img src="images/golden-ticket.jpg" />

## Symmetry is your golden ticket
















---

template: inverse

# Multiple Paths

AKA

# Model-based testing

---
template: image-white

<img src="http://fsharpforfunandprofit.com/assets/img/property_commutative.png" style="margin-top: 120px;"/>

---

## List

```scala
forAll { l: List[Boolean] =>
  l.partition(b => b) =?
    (l.filter(b => b), l.filter(b => !b))
}

forAll { (l: List[Int], i: Int) =>
  l.take(i) ++ l.drop(i) =? l
}

forAll { (l: List[Int], i: Int) =>
  l.splitAt(i) =?
    (l.take(i), l.drop(i))
}
```

---

## Aliases

```scala
forAll { l: List[Int] =>
  l.size =? l.length
}

forAll { l: List[Boolean] =>
  l.filterNot(b => b) =? l.filter(b => !b)
}
```

---

## Performance - Crazy Town

```scala
def sum(l: List[Int]): Int = {
  var v = 0
  l.foreach ( i => v += i )
  v
}

forAll { l: List[Int] =>
  sum(l) =? l.foldLeft(0)(_ + _)
}

forAll { l: List[Int] =>
  quickSort(l) =? bubbleSort(l)
}
```

---
## Database

```scala
forAll { users: List[User] =>
  users.foreach(u => UserDB.insert(u))
  val u = UserDB.listSortByName

  u =? users.sortBy(_.name)
}
```

---
template: ambiata

## Example in the wild

```scala
def dayPlus(d: Date, i: Int): Date = {
  ...
}

forAll { d: Date =>
  d.toJoda.fromJoda =? d
}

forAll { (d: Date, i: Int) =>
  dayPlus(d, i) =?
    d.toJoda.plusDays(i).fromJoda
}
```

---
template: rule

```
A counter-example is [Date(2004,3,1), 1] (after 1 try)
'Date(2004,2,28)' is not equal to 'Date(2004,2,29)'
```

















---

template: inverse

# Induction

---
layout: false

## Induction

```scala
Nil.size =? 0

forAll { (i: Int, l: List[Int]) =>
  (i :: l).size =? (l.size + 1)
}
```

---

## Induction to the rescue

```scala
Nil.headOption =? None

forAll { (h: Int, t: List[Int]) =>
  (h :: t).headOption =? Some(h)
}
```

















---

template: inverse

# Invariants

---
layout: false

## Collect them all

```scala
forAll { l: List[Int] =>
  l.map(i => i).size =? l.size
}
```

```scala
forAll { l: List[Int] =>
  l.sorted.size =? l.size
}
```

```scala
forAll { l: List[Int] =>
  l.reverse.size =? l.size
}
```

---
## Invariants

```scala
forAll { l: List[Int] =>
  l.filter(_ => true) =? l
}

forAll { l: List[Int] =>
  l.filter(_ => false) =? Nil
}

forAll { l: List[Int] =>
  l.map(i => i) =? l
}
```

---

## Idempotence

```scala
forAll { s: String =>
  s.distinct.distinct =? s.distinct
}

forAll { s: String =>
  s.sorted.sorted =? s.sorted
}
```

---
## Consistency

```scala
forAll { (s1: String, s2: String) =>
  val f = File.createTempFile
  write(f, s1)
  write(f, s2)
  read(f) =? s2
}
```

---

## Database Consistency

```scala
forAll { (u1: User, u2: User) =>

  UserDB.insert(u1)
  val i2 = UserDB.insert(u2)
  val u3 = UserDB.get(i2)

  u3 =? Some(u2)
}
```

---
template: rule

```
User with name already exists
> ARG_0: User("bob")
> ARG_1: User("bob")
```

---
## Preconditions

```scala
forAll { (u1: User, u2: User) =>
          u1.name != u2.name ==>

  val i1 = UserDB.insert(u1)
  val i2 = UserDB.insert(u2)
  val u3 = UserDB.get(i2.get)

  u3 =? Some(u2)
}
```

---
## Warning: Preconditions

```scala
forAll { (u1: User, u2: User) =>
          u1.name == u2.name ==>

  val i1 = UserDB.insert(u1)
  val i2 = UserDB.insert(u2)

  (i1.isDefined, i2.isEmpty) =? (true, true)
}
```

---
template: rule

```
Gave up after only 1 passed tests.
100 tests were discarded.
```

---
## Invariants

```scala
forAll { (u1: User, u2: User) =>
  val i1 = UserDB.insert(u1)
  val i2 = UserDB.insert(u2.copy(name = u1.name))

  (i1.isDefined, i2.isEmpty) =? (true, true)
}
```














---

template: image

<img src="images/everywhere2.jpg" height="120%" style="margin-top: -60px" />

## The same patterns everywhere























---
template: inverse

## Is it too slow to run 100 times?

---

## Minimum tests

```scala
forAll { users: List[Users] =>

  val out = runHadoopOhGodItsSlow(users)

  val expected =
    users.groupBy(_.name)
         .mapValues(_.sortBy(_.postcode))

  out =? expected

}.set(minTestsOk = 5)
```

---

## Haskell

```haskell
prop_db user = monadicIO . run $ do
  i  &lt;- insert user
  u' &lt;- load i
  stop $ i === u'

tests :: IO Bool
tests = $quickCheckWithResult (stdArgs{maxSuccess = 5})
```

---

## Not perfect but...

- Can increase/toggle runs
- Separate build with different sizes
- _Still_ better than hard-coded tests


















---
template: inverse

## Laws

---

## Usual Suspects

<img src="images/usual-suspects.jpg" width="650px" style="position: absolute; right: 20px; top: 170px;" />

- Equal
- Order
- Functor
- Monad


---

## [Scalaz](https://github.com/scalaz/scalaz/blob/master/scalacheck-binding/src/main/scala/scalaz/scalacheck/ScalazProperties.scala)

```scala
libraryDependencies +=
  "org.scalaz" %% "scalaz-binding" % "7.1.2"

property("user equal") =
  scalaz.scalacheck.equal.laws[User]

property("set functor")
  scalaz.scalacheck.functor.laws[Set]

property("db monad")
  scalaz.scalacheck.monad.laws[DB]
```

---

## JSON

```scala
def toFromJSON
  [A: EncodeJson: DecodeJson: Arbitrary: Equal]: Prop =

  Prop.forAll { a =>
    fromJson(toJson(a)) =? Right(a)
  }
```

```scala
property("user") = toFromJSON[User]
property("job") = toFromJSON[Job]
```

- [Argonaut CodecLaw](https://github.com/argonaut-io/argonaut/blob/master/src/main/scala/argonaut/CodecJson.scala#L19)

---

## Idempotence

```scala
def idempotence[A: Equal](i: A, f: A => A) =
  f(f(i)) =? f(i)
```

---

## "Abstraction"

```scala
trait DB {
  def create(user: User): UserId
  def read(id: UserId): Option[UserId]
  ...
}

object PostgresDB extends DB
object MemoryDB extends DB
```

- Could be your Free interpreters

---

## Database Laws

```scala
def dbLaws(db: DB): Prop = new Properties("DB Laws") {

  property("symmetry") = forAll { (u: User) =>
    db.read(db.create(u)) =? Some(u)
  }

  property("empty") = forAll { (id: UserId) =>
    db.read(id) =? None
  }
}
```

```scala
property("postgres DB laws") = dbLaws[PostgresDB]
property("memory DB laws") = dbLaws[MemoryDB]
```

---

## Haskell

```haskell
dbLaws :: DB -> Property

dbLaws db = conjoin [
    property $ dbSymmetry db
  , property $ dbEmpty db
  ]
```















---

template: inverse

# Easy Wins

---

## Free Variables

```scala
def testUser = {
  val user = User("bob", 2000)
  val id = db.insert(user)
  db.load(id) =? user
}
```


```scala
forAll { (name: String, postcode: Int) =>
  val user = User(name, postcode)
  val id = db.insert(user)
  db.load(id) =? user
}
```

---
template: rule

```
Invalid postcode
> ARG_0: "bob"
> ARG_1: -1
```

---

## Documentation is awesome

```scala
object UserDB {

  /**
   * Adds a user.
   *
   * Fails if the postcode is negative.
   */
  def insert(user: User): Unit
}
```

---

## Business Rules

```scala
def genPostcode: Gen[Int] =
  Gen.choose(1, 8000)

def genUsername: Gen[String] =
  Gen.string


forAll(genUsername, genPostcode) {
  (name: String, postcode: Int) =>

  ...
}
```

---

## Changing Requirements

```scala
def genPostcode: Gen[Int] =
  Gen.choose(1, 9999)

def genUsername: Gen[String] =
  Gen.frequency(
    19 -> Gen.string
  , 1  -> Gen.const("null")
  )
```
---

template: question

# Type Driven Development

---

## Be Precise

```scala
class Postcode private(val value: Int) extends AnyVal

object Postcode {
  
  def fromInt(i: Int): Option[Postcode] =
    if (i > 0 || i &lt; 10000)
      Some(new Postcode(i))
    else
      None
}
```

---

## Types with Benefits

```scala
forAll { (name: Username, postcode: Postcode) =>
   ...
}
```

---

template: image

<img src="images/everywhere2.jpg" height="120%" style="margin-top: -60px" />

## Types for everything




















---
template: inverse

## @mhibberd
## "Maybe you could test a relatively well known open source library and find a bug for something they have unit tests for"

---
template: image-white

<img src="images/challenge.jpg" />

---

## Joda

```scala
import org.joda.time._

forAll { dt: DateTime =>
  val formatter = DateTimeFormat.fullDateTime()
  val s = formatter.print(dt)
  formatter.parseDateTime(s) =? dt
}
```

---
template: rule

```
Invalid format:
"Sunday, September 22, 2148 9:08:08 PM ART"
is malformed at "ART"
```

---

## Bug or Feature?

- http://stackoverflow.com/questions/15642053/joda-time-parsing-string-throws-java-lang-illegalargumentexception
- http://comments.gmane.org/gmane.comp.java.joda-time.user/1385
- https://github.com/JodaOrg/joda-time/commit/14863a51230b3d44201646dbc1ce5d7f6bb97a33

---
template: image-white

<a href="https://twitter.com/da_terry/status/587602658011189252">
  <img src="images/alex.png" >
</a>

---

```scala
import org.rauschig.jarchivelib._

def archiveLaws(format: ArchiveFormat): Prop =
  forAll { files: Map[FilePath, Array[Byte]] => {

  val archiver = ArchiverFactory.createArchiver(format)
  withTmpDir { dir =>
    val archive = archiver.create(dir, files)
    archive.loadAll() =? files
  }
}

archiveLaws(ArchiveFormat.Jar)
archiveLaws(ArchiveFormat.7zip)
archiveLaws(ArchiveFormat.Ar)
```
---

## TIL

- `file name 'aὠ눧䄬裦㕃띶੩軃ꨣ昚댃㏔磝ꕠ忎⽪滊槔  螎鴲뻣ᛍ䆕䡟ꘘ뱷꒙떓' is too long ( > 100 bytes)`
- `java.nio.file.InvalidPathException: Nul character not allowed`
- `Expected "aⲐ" "a?"`

---

# Haskell Too

```haskell
import Data.Aeson

toFromJSON :: (ToJSON a, FromJSON a, Eq a, Show a) =>
  a -> Property

prop_time :: UTCTime -> Property
prop_time = toFromJSON
```

---
template: rule

```
Failed! Falsifiable (after 1 test and 54 shrinks):
1858-11-17 00:00:00.000000000001 UTC

Right 1858-11-17 00:00:00 UTC /=
  Right 1858-11-17 00:00:00.000000000001 UTC
```

---

## Bug

- https://github.com/bos/aeson/issues/240
- https://github.com/bos/aeson/pull/241
- "Updates UTCTime ToJSON instance to output full picosecond resolution"









---
template: inverse

# Closing Arguments

---

## Quicktip - Boolean

- Scala
  - `def ?=[T](x: T, y: T)(implicit pp: T => Pretty): Prop`
- Haskell
  - `(===) :: (Eq a, Show a) => a -> a -> Property`



---
template: ambiata

## Ambiata

- We have a majority of property-based tests
- Our default
- Need a compelling reason to write unit tests

---
template: ambiata

## https://github.com/ambiata/ivory

- ~600 properties
- ~40 Hadoop properties
- ~20 non-property tests
  - Mostly integration/sanity tests
- ~20 minutes to run

---
template: ambiata

## Ambiata - Libraries

- https://github.com/ambiata/disorder
  - Umbrella project
- https://github.com/ambiata/disorder.scala
  - DistinctPair
  - PositiveInt
- https://github.com/ambiata/disorder.hs
  - Main runner
  - Aeson/Lens laws

---
template: image-white
class: top

<img src="images/all-the-things.png" height="100%" />

# Property Tests

---
layout: false

## Links

- "Choosing properties for property-based testing"
  - http://fsharpforfunandprofit.com/posts/property-based-testing-2/
- John Hughes - "Testing the Hard Stuff and Staying Sane"
  - https://www.youtube.com/watch?v=zi0rHwfiX1Q
- Jessica Kerr - "Property-Based Testing for Better Code"
  - https://www.youtube.com/watch?v=shngiiBfD80
- https://github.com/charleso/property-testing-preso


    </textarea>
    <script src="js/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>.
